<!doctype html>
<html>
  <head>
    <title>computational complexity</title>
    <link type="text/css" rel="stylesheet" href="index.css" />
    <link rel="icon" type="image/x-icon" href="../../media/favicon.ico">
    <script src="../../menu/menu.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <br/>
    <br/>
    <div class="article">
        <h1>computational complexity</h1>
        <h4>apr 9, 2022</h4>
        <p><i>Computational complexity is the estimate of computer resources an algorithm needs to complete a run. In it there's a particular focus on two qualities: time and space.</i></p>
        <br/>
        <h3>time complexity</h3>
        <p>We should begin by saying time complexity is not the actual hours:minutes:seconds required to execute any particular piece of code. That depends on a myriad of factors like programming language, operating system and processing power.</p>
        <p>Instead, time complexity describes how the number of operations an algorithm performs changes with its input size. If our input doubles in size, do the number of operations performed also double? Does it stay the same? What if our input get smaller?</p>
        <br/>
        <h3>space complexity</h3>
        <p>The space complexity of an algorithm is the amount of memory it requires for a run. Similar to time complexity, this is measured relative to changes in input size.</p>
        <p>It’s sum is <i>space complexity = auxiliary space + input space.</i></p>
        <p>Auxiliary space is defined as all the memory used inside the algorithm itself (think variables, loops, data structures, etc). In contrast, input space is the memory used for the data that goes into the algorithm for processing. Differentiating that, when comparing different algorithms' space complexity, we would only consider auxiliary space since they’re solutions accepting the same input.</p>
        <br/>
        <h5>constant operation - O(1)</h5>
        <p>An algorithm is said to have constant time or space, O(1), when the resources it uses is independent of input. Simply -- it completes the same number of tasks and uses the same amount of memory no matter the input size.</p>
        <h5>logarthmic operation - O(log n)</h5>
        <p>An algorithm is said to be logarithmic, O(log n), when the time and space used begins at the inputs initial length, but is divided by some constant (usually two) each iteration until its less than or equal to 1.</p>
        <h5>linear operation - O(n)</h5>
        <p>An algorithm is said to be linear, O(n), when it's time and memory increases proportionally (1 to 1) with its input size. This occurs in cases when we have input data that needs to have every value inside it processed, and each of those assessments is constant, O(1). This growth can be understood as <i>cn</i>, where <i> c = 1 and n = input length</i>.</p>
        <h5>quadratic operation - O(n<sup>2</sup>)</h5>
        <p>An algorithm is said to be quadratic,  O(n<sup>2</sup>), when its resources increases proportionally to the squared size of the input length. This occurs in cases when we have data that needs to have every value inside it processed, but each of those assessments must process the entire length of the original input with it.</p>
        <br/>
        <h3>big-o chart</h3>
        <p>An illustration of how increasing input lengths affect different big-o complexities:</p>
        <img src="../../media/chart.svg" width="350px;" height="250px;">
    </div>
  </body>
</html>
